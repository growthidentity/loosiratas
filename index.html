<!DOCTYPE html>
<html lang="et">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PumpPick</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;500;600;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Rajdhani', sans-serif;
    background: #050510;
    color: #c0d0e0;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Grid bg */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background:
      linear-gradient(rgba(0,255,170,0.02) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,255,170,0.02) 1px, transparent 1px);
    background-size: 60px 60px;
    pointer-events: none;
    z-index: 0;
  }

  .scanlines {
    position: fixed;
    inset: 0;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px);
    pointer-events: none;
    z-index: 99;
  }

  /* Ticker tape */
  .ticker {
    width: 100%;
    background: rgba(0,255,170,0.04);
    border-bottom: 1px solid rgba(0,255,170,0.1);
    overflow: hidden;
    padding: 0.4rem 0;
    position: relative;
    z-index: 2;
  }
  .ticker-inner {
    display: flex;
    gap: 3rem;
    animation: tickerScroll 25s linear infinite;
    white-space: nowrap;
    font-family: 'Orbitron', monospace;
    font-size: 0.6rem;
    letter-spacing: 1px;
  }
  @keyframes tickerScroll {
    0% { transform: translateX(0); }
    100% { transform: translateX(-50%); }
  }
  .ticker-item { display: flex; align-items: center; gap: 0.5rem; }
  .ticker-item .pair { color: #607080; }
  .ticker-item .price { color: #c0d0e0; }
  .ticker-item .change.up { color: #00ffaa; }
  .ticker-item .change.down { color: #ff4466; }

  .page {
    position: relative;
    z-index: 1;
    max-width: 1200px;
    margin: 0 auto;
    padding: 1rem 1.5rem 3rem;
  }

  /* Header */
  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1.2rem;
    flex-wrap: wrap;
    gap: 1rem;
  }
  .header-left { display: flex; align-items: center; gap: 1rem; }
  .header h1 {
    font-family: 'Orbitron', monospace;
    font-size: 1.8rem;
    font-weight: 900;
    letter-spacing: 4px;
    text-transform: uppercase;
    background: linear-gradient(135deg, #00ffaa 0%, #00d4ff 50%, #a855f7 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    filter: drop-shadow(0 0 15px rgba(0,255,170,0.3));
  }
  .live-badge {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.25rem 0.8rem;
    background: rgba(80,100,120,0.08);
    border: 1px solid rgba(80,100,120,0.2);
    border-radius: 20px;
    transition: background 0.3s, border-color 0.3s;
  }
  .live-badge.active {
    background: rgba(0,255,170,0.06);
    border-color: rgba(0,255,170,0.15);
  }
  .live-badge .dot {
    width: 6px; height: 6px;
    background: #506070;
    border-radius: 50%;
    transition: background 0.3s, box-shadow 0.3s;
  }
  .live-badge.active .dot {
    background: #00ffaa;
    box-shadow: 0 0 6px #00ffaa;
    animation: pulse 1.5s ease-in-out infinite;
  }
  @keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.4; transform: scale(0.8); }
  }
  .live-badge span {
    font-family: 'Orbitron', monospace;
    font-size: 0.5rem;
    letter-spacing: 2px;
    color: #50607088;
    text-transform: uppercase;
    transition: color 0.3s;
  }
  .live-badge.active span { color: #00ffaa88; }

  /* Input area */
  .input-row {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
  }
  .input-panel {
    background: rgba(8,12,25,0.9);
    border: 1px solid rgba(0,255,170,0.1);
    border-radius: 12px;
    padding: 1rem;
    flex: 1;
    min-width: 250px;
    position: relative;
  }
  .input-panel::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(0,255,170,0.3), transparent);
  }
  .input-panel label {
    font-family: 'Orbitron', monospace;
    font-size: 0.5rem;
    letter-spacing: 2px;
    color: #00ffaa55;
    text-transform: uppercase;
    display: block;
    margin-bottom: 0.5rem;
  }
  textarea {
    width: 100%;
    height: 100px;
    background: rgba(3,5,15,0.9);
    border: 1px solid rgba(0,255,170,0.08);
    border-radius: 8px;
    color: #c0e8d8;
    font-family: 'Rajdhani', monospace;
    font-size: 1rem;
    font-weight: 500;
    padding: 0.6rem;
    resize: vertical;
    outline: none;
    transition: border-color 0.3s;
    line-height: 1.5;
  }
  textarea::placeholder { color: #152030; }
  textarea:focus { border-color: rgba(0,255,170,0.25); }

  /* Stats bar */
  .stats-bar {
    display: flex;
    gap: 1.5rem;
    align-items: center;
    flex-wrap: wrap;
  }
  .stat-box {
    display: flex;
    align-items: center;
    gap: 0.4rem;
  }
  .stat-box .lbl {
    font-family: 'Orbitron', monospace;
    font-size: 0.45rem;
    letter-spacing: 2px;
    color: #253040;
    text-transform: uppercase;
  }
  .stat-box .val {
    font-family: 'Orbitron', monospace;
    font-size: 0.75rem;
    color: #00ffaa;
    font-weight: 700;
  }

  /* Spin button */
  .spin-btn {
    font-family: 'Orbitron', monospace;
    font-size: 0.75rem;
    font-weight: 700;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: #050510;
    background: linear-gradient(135deg, #00ffaa, #00d4ff);
    border: none;
    border-radius: 8px;
    padding: 0.6rem 2rem;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  .spin-btn:hover:not(:disabled) {
    transform: scale(1.03);
    box-shadow: 0 0 25px rgba(0,255,170,0.3);
  }
  .spin-btn:disabled { opacity: 0.3; cursor: not-allowed; }

  /* Chart area */
  .chart-container {
    background: rgba(8,12,25,0.9);
    border: 1px solid rgba(0,255,170,0.1);
    border-radius: 16px;
    padding: 1.2rem;
    position: relative;
    overflow: hidden;
  }
  .chart-container::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(0,255,170,0.4), rgba(0,212,255,0.4), transparent);
  }
  .chart-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.8rem;
  }
  .chart-title {
    font-family: 'Orbitron', monospace;
    font-size: 0.6rem;
    letter-spacing: 3px;
    color: #00ffaa66;
    text-transform: uppercase;
  }
  .chart-name-flash {
    font-family: 'Orbitron', monospace;
    font-size: 1rem;
    font-weight: 900;
    color: #506070;
    letter-spacing: 2px;
    min-width: 200px;
    text-align: right;
    transition: color 0.1s;
  }
  .chart-name-flash.green { color: #00ffaa; text-shadow: 0 0 15px rgba(0,255,170,0.5); }
  .chart-name-flash.red { color: #ff4466; }

  #chart {
    width: 100%;
    height: 500px;
    display: block;
    border-radius: 8px;
  }

  /* Winner overlay */
  .winner-overlay {
    position: fixed;
    inset: 0;
    z-index: 200;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
  }
  .winner-overlay.active { opacity: 1; }
  .winner-overlay .bg {
    position: absolute;
    inset: 0;
    background: rgba(5,5,16,0.7);
  }
  .winner-card {
    position: relative;
    text-align: center;
    animation: cardIn 0.6s ease-out;
  }
  @keyframes cardIn {
    0% { transform: scale(0.3) translateY(50px); opacity: 0; }
    60% { transform: scale(1.05); }
    100% { transform: scale(1) translateY(0); opacity: 1; }
  }
  .winner-card .pump-label {
    font-family: 'Orbitron', monospace;
    font-size: 1rem;
    letter-spacing: 8px;
    color: #00ffaa66;
    text-transform: uppercase;
  }
  .winner-card .pump-name {
    font-family: 'Orbitron', monospace;
    font-size: 3.5rem;
    font-weight: 900;
    background: linear-gradient(135deg, #00ffaa, #00d4ff, #a855f7);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    filter: drop-shadow(0 0 30px rgba(0,255,170,0.4));
    margin: 0.3rem 0;
  }
  .winner-card .pump-pct {
    font-family: 'Orbitron', monospace;
    font-size: 2rem;
    font-weight: 700;
    color: #00ffaa;
    text-shadow: 0 0 20px rgba(0,255,170,0.5);
  }
  .winner-card .pump-sub {
    font-family: 'Orbitron', monospace;
    font-size: 0.6rem;
    letter-spacing: 4px;
    color: #00ffaa44;
    text-transform: uppercase;
    margin-top: 0.5rem;
  }

  /* Shuffle button */
  .shuffle-btn {
    font-family: 'Orbitron', monospace;
    font-size: 0.7rem;
    font-weight: 700;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: #050510;
    background: linear-gradient(135deg, #a855f7, #00d4ff);
    border: none;
    border-radius: 8px;
    padding: 0.6rem 2rem;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  .shuffle-btn:hover:not(:disabled) {
    transform: scale(1.03);
    box-shadow: 0 0 20px rgba(168,85,247,0.3);
  }
  .shuffle-btn:disabled { opacity: 0.3; cursor: not-allowed; }

  /* Timeframe buttons */
  .tf-buttons { display: flex; gap: 3px; }
  .tf-btn {
    font-family: 'Orbitron', monospace;
    font-size: 0.5rem;
    letter-spacing: 1px;
    padding: 0.25rem 0.6rem;
    background: rgba(15,20,35,0.8);
    border: 1px solid rgba(0,255,170,0.08);
    color: #405060;
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.2s;
  }
  .tf-btn:hover:not(.active):not(:disabled) { border-color: rgba(0,255,170,0.2); color: #607080; }
  .tf-btn.active {
    background: rgba(0,255,170,0.08);
    border-color: rgba(0,255,170,0.25);
    color: #00ffaa;
  }
  .tf-btn:disabled { opacity: 0.3; cursor: not-allowed; }

  .confetti-canvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 250;
  }
</style>
</head>
<body>

<div class="scanlines"></div>

<div class="ticker"><div class="ticker-inner" id="tickerInner"></div></div>

<div class="page">
  <div class="header">
    <div class="header-left">
      <h1>PumpPick</h1>
      <div class="live-badge" id="liveBadge"><div class="dot" id="liveDot"></div><span id="liveText">Ootel</span></div>
    </div>
  </div>

  <div class="input-row">
    <div class="input-panel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
        <label style="margin:0;">Kleebi nimed (iga nimi eraldi real)</label>
        <button class="shuffle-btn" id="shuffleBtn" onclick="shuffleTextarea()" style="padding:0.35rem 1rem;font-size:0.55rem;letter-spacing:2px;">Sega</button>
      </div>
      <textarea id="names" placeholder="Mari Maasikas&#10;Jaan Jansen&#10;Kati Karu&#10;Toomas Tamm"></textarea>
    </div>
    <div class="input-panel" style="flex:0; min-width: auto; display:flex; flex-direction:column; justify-content:space-between; gap:0.8rem;">
      <div class="stats-bar" style="flex-direction:column; align-items:flex-start;">
        <div class="stat-box"><span class="lbl">Osalejaid</span><span class="val" id="nameCount">0</span></div>
        <div class="stat-box"><span class="lbl">V&otilde;idu %</span><span class="val" id="winChance">-</span></div>
        <div class="stat-box"><span class="lbl">Staatus</span><span class="val" id="statusText" style="color:#506070;">Ootel</span></div>
      </div>
      <button class="spin-btn" id="spinBtn" onclick="startRace()">Alusta</button>
    </div>
  </div>

  <div class="chart-container">
    <div class="chart-header">
      <div style="display:flex;align-items:center;gap:0.8rem;">
        <div class="chart-title">Winner / USD</div>
        <div class="tf-buttons">
          <button class="tf-btn active" data-tf="1">1s</button>
          <button class="tf-btn" data-tf="3">3s</button>
          <button class="tf-btn" data-tf="5">5s</button>
          <button class="tf-btn" data-tf="10">10s</button>
        </div>
      </div>
      <div class="chart-name-flash" id="nameFlash">&mdash;</div>
    </div>
    <canvas id="chart"></canvas>
  </div>

</div>

<div class="winner-overlay" id="winnerOverlay">
  <div class="bg"></div>
  <div class="winner-card">
    <div class="pump-label">Palju &otilde;nne!</div>
    <div class="pump-name" id="winnerName"></div>
    <div class="pump-pct" id="winnerPct"></div>
    <div class="pump-sub">To the moon</div>
  </div>
</div>

<canvas class="confetti-canvas" id="confetti"></canvas>

<script>
// ─── TICKER ─────────────────────────────────────────────
const pairs = ['WIN/USD','LOT/BTC','LUCK/ETH','SPIN/EUR','RATAS/USD','AUHIND/JPY','LOOSI/GBP'];
function buildTicker() {
  let html = '';
  for (let r = 0; r < 3; r++) pairs.forEach(p => {
    const pr = (Math.random() * 900 + 100).toFixed(2);
    const ch = (Math.random() * 10 - 3).toFixed(2);
    const up = parseFloat(ch) >= 0;
    html += `<div class="ticker-item"><span class="pair">${p}</span><span class="price">${pr}</span><span class="change ${up?'up':'down'}">${up?'+':''}${ch}%</span></div>`;
  });
  document.getElementById('tickerInner').innerHTML = html;
}
buildTicker();
setInterval(buildTicker, 12000);

// ─── CHART ──────────────────────────────────────────────
const chartCanvas = document.getElementById('chart');
const cCtx = chartCanvas.getContext('2d');
const namesEl = document.getElementById('names');
const nameCountEl = document.getElementById('nameCount');
const winChanceEl = document.getElementById('winChance');
const statusText = document.getElementById('statusText');
const nameFlash = document.getElementById('nameFlash');
const spinBtn = document.getElementById('spinBtn');

let names = [];
let racing = false;
let selectedTimeframe = 1;

// Timeframe buttons
document.querySelectorAll('.tf-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    if (racing) return;
    document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    selectedTimeframe = parseInt(btn.dataset.tf);
  });
});
let raceCandles = [];
let nameFlashTimer = null;
let overlayShowTimer = null;
let overlayHideTimer = null;
let confettiAnimFrame = null;
let candleAnimFrame = null;
let lastHighlightState = false;
let hoveredCandleIndex = -1;

chartCanvas.addEventListener('mousemove', (e) => {
  if (raceCandles.length === 0) { hoveredCandleIndex = -1; return; }
  const rect = chartCanvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * 2; // canvas is 2x
  const cw = chartCanvas.width;
  const margin = 20;
  const chartW = cw - margin * 2;
  const gap = chartW / raceCandles.length;
  const idx = Math.floor((mx - margin) / gap);
  const newIdx = (idx >= 0 && idx < raceCandles.length) ? idx : -1;
  chartCanvas.style.cursor = (newIdx >= 0 && raceCandles[newIdx]?.name) ? 'pointer' : 'default';
  if (newIdx !== hoveredCandleIndex) {
    hoveredCandleIndex = newIdx;
    if (!candleAnimFrame) drawChart(raceCandles, lastHighlightState);
  }
});
chartCanvas.addEventListener('mouseleave', () => {
  if (hoveredCandleIndex !== -1) {
    hoveredCandleIndex = -1;
    if (!candleAnimFrame) drawChart(raceCandles, lastHighlightState);
  }
});

function getNames() {
  return namesEl.value.split('\n').map(n => n.trim()).filter(n => n.length > 0);
}
namesEl.addEventListener('input', () => {
  if (racing) return;
  names = getNames();
  nameCountEl.textContent = names.length;
  winChanceEl.textContent = names.length > 0 ? (100 / names.length).toFixed(1) + '%' : '-';
});

function resizeChart() {
  const rect = chartCanvas.getBoundingClientRect();
  chartCanvas.width = rect.width * 2;
  chartCanvas.height = rect.height * 2;
}
resizeChart();
window.addEventListener('resize', () => {
  resizeChart();
  drawChart(raceCandles, lastHighlightState);
});

function drawChart(candles, highlightLast) {
  lastHighlightState = highlightLast;
  const w = chartCanvas.width;
  const h = chartCanvas.height;
  cCtx.clearRect(0, 0, w, h);

  if (candles.length === 0) {
    cCtx.fillStyle = '#15202e';
    cCtx.font = '600 28px Rajdhani, sans-serif';
    cCtx.textAlign = 'center';
    cCtx.textBaseline = 'middle';
    cCtx.fillText('Lisa nimesid ja vajuta "Alusta"', w / 2, h / 2);
    return;
  }

  // Price range
  const allP = candles.flatMap(c => [c.high, c.low]);
  let minP = Math.min(...allP);
  let maxP = Math.max(...allP);
  const pad = maxP - minP < 5 ? 10 : (maxP - minP) * 0.15;
  minP -= pad;
  maxP += pad;
  const range = maxP - minP || 1;

  const margin = { top: 30, bottom: 20, left: 20, right: 20 };
  const chartW = w - margin.left - margin.right;
  const chartH = h - margin.top - margin.bottom;
  const priceH = chartH * 0.7; // Price chart uses top 70%

  const toY = p => margin.top + (1 - (p - minP) / range) * priceH;
  const totalSlots = candles.length;
  const visible = candles;
  const candleW = (chartW / totalSlots) * 0.65;
  const gap = chartW / totalSlots;

  // Horizontal grid + price labels
  cCtx.textAlign = 'right';
  cCtx.textBaseline = 'middle';
  cCtx.font = '20px Rajdhani, sans-serif';
  for (let i = 0; i <= 5; i++) {
    const p = minP + (i / 5) * range;
    const y = toY(p);
    cCtx.strokeStyle = 'rgba(0,255,170,0.04)';
    cCtx.lineWidth = 1;
    cCtx.beginPath();
    cCtx.moveTo(margin.left, y);
    cCtx.lineTo(w - margin.right, y);
    cCtx.stroke();
    cCtx.fillStyle = '#1a2a3a';
    cCtx.fillText(p.toFixed(1), w - 4, y);
  }

  // MA line
  if (candles.length > 10) {
    cCtx.beginPath();
    cCtx.strokeStyle = 'rgba(168,85,247,0.25)';
    cCtx.lineWidth = 2;
    const maPeriod = Math.min(10, candles.length);
    const startI = 0;
    for (let i = startI; i < candles.length; i++) {
      const fromI = Math.max(0, i - maPeriod);
      let sum = 0, cnt = 0;
      for (let j = fromI; j <= i; j++) { sum += candles[j].close; cnt++; }
      const ma = sum / cnt;
      const vi = i - startI;
      const x = margin.left + vi * gap + gap / 2;
      if (i === startI) cCtx.moveTo(x, toY(ma));
      else cCtx.lineTo(x, toY(ma));
    }
    cCtx.stroke();
  }

  // Candles (price area)
  visible.forEach((c, i) => {
    const x = margin.left + i * gap + gap / 2;
    const bullish = c.close >= c.open;
    const isLast = i === visible.length - 1;
    const isWinner = isLast && highlightLast;

    let color = bullish ? '#00ffaa' : '#ff4466';
    if (isWinner) color = '#00ffaa';

    const bodyTop = toY(Math.max(c.open, c.close));
    const bodyBot = toY(Math.min(c.open, c.close));
    const bodyH = Math.max(2, bodyBot - bodyTop);

    // Wick
    cCtx.strokeStyle = color + (isWinner ? 'ff' : '88');
    cCtx.lineWidth = isWinner ? 3 : 1.5;
    cCtx.beginPath();
    cCtx.moveTo(x, toY(c.high));
    cCtx.lineTo(x, toY(c.low));
    cCtx.stroke();

    // Body
    const bw = isWinner ? candleW * 1.8 : candleW;
    cCtx.fillStyle = bullish ? color : (isWinner ? color : '#cc3355');
    cCtx.fillRect(x - bw / 2, bodyTop, bw, bodyH);

    // Name labels
    if (c.name) {
      cCtx.save();
      const labelColor = bullish ? '#00ffaa' : '#ff4466';
      const wickTop = toY(c.high);

      if (isLast || isWinner) {
        // === Full floating label box for current / winner ===
        const labelY = wickTop - 14;
        const priceStr = (bullish ? '+' : '') + (c.close - c.open).toFixed(2) + '  O:' + c.open.toFixed(1) + '  C:' + c.close.toFixed(1);
        const nameFontSize = isWinner ? 22 : 16;
        cCtx.font = `700 ${nameFontSize}px Rajdhani, sans-serif`;
        const nameW = cCtx.measureText(c.name).width;
        cCtx.font = '500 12px Rajdhani, sans-serif';
        const priceW = cCtx.measureText(priceStr).width;
        const boxW = Math.max(nameW, priceW) + 20;
        const boxH = isWinner ? 52 : 44;
        let boxX = x - boxW / 2;
        if (boxX < margin.left) boxX = margin.left;
        if (boxX + boxW > w - margin.right) boxX = w - margin.right - boxW;
        const boxY = labelY - boxH;
        cCtx.fillStyle = 'rgba(8,12,25,0.92)';
        cCtx.beginPath();
        cCtx.roundRect(boxX, boxY, boxW, boxH, 6);
        cCtx.fill();
        cCtx.strokeStyle = labelColor + (isWinner ? '88' : '44');
        cCtx.lineWidth = 1;
        cCtx.stroke();
        cCtx.font = `700 ${nameFontSize}px Rajdhani, sans-serif`;
        cCtx.textAlign = 'center';
        cCtx.textBaseline = 'top';
        cCtx.fillStyle = labelColor;
        cCtx.fillText(c.name, boxX + boxW / 2, boxY + 6);
        cCtx.font = '500 12px Rajdhani, sans-serif';
        cCtx.fillStyle = '#506878';
        cCtx.fillText(priceStr, boxX + boxW / 2, boxY + 6 + nameFontSize + 2);
        cCtx.strokeStyle = labelColor + '44';
        cCtx.lineWidth = 1;
        cCtx.beginPath();
        cCtx.moveTo(x, boxY + boxH);
        cCtx.lineTo(x, wickTop);
        cCtx.stroke();
      } else if (i === hoveredCandleIndex) {
        // === Hovered: show full floating label box ===
        const labelY = wickTop - 10;
        const priceStr = (bullish ? '+' : '') + (c.close - c.open).toFixed(2) + '  O:' + c.open.toFixed(1) + '  C:' + c.close.toFixed(1);
        const nameFontSize = 14;
        cCtx.font = `700 ${nameFontSize}px Rajdhani, sans-serif`;
        const nameW = cCtx.measureText(c.name).width;
        cCtx.font = '500 11px Rajdhani, sans-serif';
        const priceW = cCtx.measureText(priceStr).width;
        const boxW = Math.max(nameW, priceW) + 16;
        const boxH = 40;
        let boxX = x - boxW / 2;
        if (boxX < margin.left) boxX = margin.left;
        if (boxX + boxW > w - margin.right) boxX = w - margin.right - boxW;
        const boxY = labelY - boxH;
        cCtx.fillStyle = 'rgba(8,12,25,0.94)';
        cCtx.beginPath();
        cCtx.roundRect(boxX, boxY, boxW, boxH, 5);
        cCtx.fill();
        cCtx.strokeStyle = labelColor + '66';
        cCtx.lineWidth = 1;
        cCtx.stroke();
        cCtx.font = `700 ${nameFontSize}px Rajdhani, sans-serif`;
        cCtx.textAlign = 'center';
        cCtx.textBaseline = 'top';
        cCtx.fillStyle = labelColor;
        cCtx.fillText(c.name, boxX + boxW / 2, boxY + 5);
        cCtx.font = '500 11px Rajdhani, sans-serif';
        cCtx.fillStyle = '#506878';
        cCtx.fillText(priceStr, boxX + boxW / 2, boxY + 5 + nameFontSize + 1);
        cCtx.strokeStyle = labelColor + '33';
        cCtx.lineWidth = 1;
        cCtx.beginPath();
        cCtx.moveTo(x, boxY + boxH);
        cCtx.lineTo(x, wickTop);
        cCtx.stroke();
      } else {
        // === Small vertical name above wick for old candles ===
        const fs = Math.max(7, Math.min(gap * 0.55, 12));
        cCtx.translate(x, wickTop - 3);
        cCtx.rotate(-Math.PI / 2);
        cCtx.font = `600 ${fs}px Rajdhani, sans-serif`;
        cCtx.textAlign = 'left';
        cCtx.textBaseline = 'middle';
        cCtx.fillStyle = labelColor + '55';
        // Truncate if name is longer than available space
        let label = c.name;
        const maxW = wickTop - margin.top - 8;
        if (maxW > 10) {
          while (label.length > 1 && cCtx.measureText(label).width > maxW) {
            label = label.slice(0, -1);
          }
          if (label !== c.name) label += '.';
          cCtx.fillText(label, 0, 0);
        }
      }
      cCtx.restore();
    }

  });

  // ─── VOLUME SECTION: Names as bars ────────────────────
  const volTop = priceH + margin.top + 8;
  const volHeight = chartH * 0.25;

  // Separator line
  cCtx.strokeStyle = 'rgba(0,255,170,0.06)';
  cCtx.lineWidth = 1;
  cCtx.beginPath();
  cCtx.moveTo(margin.left, volTop - 4);
  cCtx.lineTo(w - margin.right, volTop - 4);
  cCtx.stroke();

  // Names as volume bars — the text IS the bar
  visible.forEach((c, i) => {
    if (!c.name) return;
    const x = margin.left + i * gap + gap / 2;
    const bullish = c.close >= c.open;
    const isLast = i === visible.length - 1;
    const isWinner = isLast && highlightLast;

    const color = (isWinner || bullish) ? '#00ffaa' : '#ff4466';
    const alpha = isWinner ? 'cc' : '44';

    cCtx.save();
    cCtx.translate(x, volTop + volHeight);
    cCtx.rotate(-Math.PI / 2);

    // Font size fits the gap width
    const fs = Math.min(gap * 0.7, 14);
    cCtx.font = `${isWinner ? '700' : '600'} ${fs}px Rajdhani, sans-serif`;
    cCtx.textAlign = 'left';
    cCtx.textBaseline = 'middle';

    // Truncate name to fit volume height
    let label = c.name;
    while (label.length > 1 && cCtx.measureText(label).width > volHeight - 4) {
      label = label.slice(0, -1);
    }
    if (label !== c.name && label.length > 0) label += '.';

    cCtx.fillStyle = color + alpha;

    if (isWinner) {
      cCtx.shadowColor = '#00ffaa';
      cCtx.shadowBlur = 8;
    }

    cCtx.fillText(label, 2, 0);
    cCtx.restore();
  });
}

// Initial empty chart
drawChart([], false);

// ─── RACE LOGIC ─────────────────────────────────────────
function cryptoRand() {
  const arr = new Uint32Array(1);
  crypto.getRandomValues(arr);
  return arr[0] / 4294967296;
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(cryptoRand() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function startRace() {
  names = getNames();
  if (names.length < 2) { alert('Lisa vahemalt 2 nime!'); return; }
  if (racing) return;
  racing = true;
  spinBtn.disabled = true;
  namesEl.disabled = true;
  document.querySelectorAll('.tf-btn').forEach(b => b.disabled = true);
  statusText.textContent = 'Trading...';
  statusText.style.color = '#00d4ff';
  document.getElementById('liveBadge').classList.add('active');
  document.getElementById('liveText').textContent = 'Live';
  document.getElementById('winnerOverlay').classList.remove('active');
  if (nameFlashTimer) { clearInterval(nameFlashTimer); nameFlashTimer = null; }
  if (overlayShowTimer) { clearTimeout(overlayShowTimer); overlayShowTimer = null; }
  if (overlayHideTimer) { clearTimeout(overlayHideTimer); overlayHideTimer = null; }
  if (confettiAnimFrame) { cancelAnimationFrame(confettiAnimFrame); confettiAnimFrame = null; }
  if (candleAnimFrame) { cancelAnimationFrame(candleAnimFrame); candleAnimFrame = null; }

  // Pick random winner using crypto
  const winnerIndex = Math.floor(cryptoRand() * names.length);
  const winnerName = names[winnerIndex];

  // Shuffle all names, remove winner
  const others = names.filter((_, i) => i !== winnerIndex);
  shuffle(others);

  // Always 30-40 candles, ~1s each. Group names into batches per candle.
  const totalCandles = 30 + Math.floor(Math.random() * 10);
  const batchSize = Math.max(1, Math.ceil(others.length / (totalCandles - 1)));

  // Split names into batches for each candle
  const batches = [];
  for (let i = 0; i < others.length; i += batchSize) {
    batches.push(others.slice(i, i + batchSize));
  }
  // Pad with small random batches if we need more candles
  while (batches.length < totalCandles - 1) {
    batches.push([others[Math.floor(Math.random() * others.length)]]);
  }
  // Last batch is always just the winner
  batches.push([winnerName]);

  // Pre-generate candle data
  const allCandles = [];
  let price = 100;
  for (let i = 0; i < batches.length; i++) {
    const isLast = i === batches.length - 1;
    const progress = i / batches.length;

    let volatility, drift;
    if (isLast) {
      volatility = 2;
      drift = 15 + Math.random() * 15;
    } else if (progress > 0.88) {
      volatility = 1 + Math.random() * 1.5;
      drift = -1.5 + Math.random() * 1;
    } else {
      volatility = 2 + Math.random() * 5;
      drift = (Math.random() - 0.48) * 3;
    }

    const open = price;
    const close = open + drift + (Math.random() - 0.5) * volatility;
    const high = Math.max(open, close) + Math.random() * volatility * 0.5;
    const low = Math.min(open, close) - Math.random() * volatility * 0.5;
    price = Math.max(1, close);

    const displayName = isLast ? winnerName : batches[i][batches[i].length - 1];
    allCandles.push({ open: Math.max(0.5, open), close: Math.max(1, close), high: Math.max(1, high), low: Math.max(0.5, low), name: displayName, names: batches[i], isWinner: isLast });
  }

  raceCandles = [];
  let candleIndex = 0;

  function addNextCandle() {
    if (candleIndex >= allCandles.length) {
      finishRace(winnerName, allCandles);
      return;
    }

    const c = allCandles[candleIndex];
    const isLast = candleIndex === allCandles.length - 1;
    const nextC = candleIndex < allCandles.length - 1 ? allCandles[candleIndex + 1] : null;

    // Create animating candle starting at open price
    const animCandle = {
      open: c.open,
      close: c.open,
      high: c.open,
      low: c.open,
      name: c.name,
      names: c.names,
      isWinner: c.isWinner
    };

    raceCandles.push(animCandle);

    const baseDur = selectedTimeframe * 1000;
    const duration = isLast ? baseDur * 1.4 : baseDur * 0.8;
    const startTime = performance.now();
    let lastNameFlick = 0;
    let batchIdx = 0;
    const batchNames = c.names;

    function animateCandle(now) {
      const elapsed = now - startTime;
      const progress = Math.min(1, elapsed / duration);

      // === PRICE FIGHTING ===
      const fightStrength = Math.max(0, 1 - progress * 1.5);
      const convergence = progress * progress * progress;

      // Random micro-movement (fight)
      const micro = (Math.random() - 0.5) * 4 * fightStrength;

      // Pull toward final close
      animCandle.close += micro + (c.close - animCandle.close) * convergence * 0.12;

      // Winner explosion in final stretch
      if (isLast && progress > 0.75) {
        const boom = (progress - 0.75) / 0.25;
        animCandle.close = c.open + (c.close - c.open) * (boom * boom);
      }

      // Track extremes
      animCandle.high = Math.max(animCandle.high, animCandle.close);
      animCandle.low = Math.min(animCandle.low, animCandle.close);

      // === NAME FLICKERING ===
      const flickerInterval = isLast ? 70 : 90;
      if (now - lastNameFlick > flickerInterval) {
        lastNameFlick = now;
        const bullish = animCandle.close >= animCandle.open;

        if (progress < 0.8) {
          // During formation: cycle batch names + flicker with next candle name
          if (nextC && Math.random() < 0.3) {
            animCandle.name = nextC.name;
            nameFlash.textContent = nextC.name;
            nameFlash.className = 'chart-name-flash ' + (Math.random() > 0.5 ? 'green' : 'red');
          } else {
            animCandle.name = batchNames[batchIdx % batchNames.length];
            nameFlash.textContent = animCandle.name;
            nameFlash.className = 'chart-name-flash ' + (bullish ? 'green' : 'red');
            batchIdx++;
          }
        } else {
          // Settling on current name
          animCandle.name = c.name;
          nameFlash.textContent = c.name;
          nameFlash.className = 'chart-name-flash ' + (bullish ? 'green' : 'red');
        }
      }

      // Redraw chart
      drawChart(raceCandles, isLast);

      if (progress < 1) {
        candleAnimFrame = requestAnimationFrame(animateCandle);
      } else {
        // Snap to final pre-generated values
        animCandle.open = c.open;
        animCandle.close = c.close;
        animCandle.high = c.high;
        animCandle.low = c.low;
        animCandle.name = c.name;
        drawChart(raceCandles, isLast);

        // Final name display
        const bullish = c.close >= c.open;
        nameFlash.textContent = c.name;
        nameFlash.className = 'chart-name-flash ' + (bullish ? 'green' : 'red');

        candleIndex++;
        candleAnimFrame = null;

        // Small pause before next candle (scales with timeframe)
        const p = candleIndex / allCandles.length;
        const gapBase = selectedTimeframe * 1000;
        let delay;
        if (p < 0.85) delay = gapBase * 0.15 + Math.random() * gapBase * 0.1;
        else if (p < 0.95) delay = gapBase * 0.3 + Math.random() * gapBase * 0.2;
        else delay = gapBase * 0.5 + Math.random() * gapBase * 0.3;

        setTimeout(addNextCandle, delay);
      }
    }

    candleAnimFrame = requestAnimationFrame(animateCandle);
  }

  addNextCandle();
}

function finishRace(winnerName, allCandles) {
  racing = false;
  spinBtn.disabled = false;
  namesEl.disabled = false;
  document.querySelectorAll('.tf-btn').forEach(b => b.disabled = false);
  if (nameFlashTimer) { clearInterval(nameFlashTimer); nameFlashTimer = null; }
  statusText.textContent = 'PUMP!';
  statusText.style.color = '#00ffaa';
  document.getElementById('liveBadge').classList.remove('active');
  document.getElementById('liveText').textContent = 'Done';

  nameFlash.textContent = winnerName;
  nameFlash.className = 'chart-name-flash green';

  // Calculate pump %
  const lastCandle = allCandles[allCandles.length - 1];
  const prevCandle = allCandles[allCandles.length - 2];
  const pumpPct = Math.min(9999, Math.abs((lastCandle.close - prevCandle.close) / prevCandle.close * 100)).toFixed(1);

  // Show winner overlay
  document.getElementById('winnerName').textContent = winnerName;
  document.getElementById('winnerPct').textContent = '+' + pumpPct + '%';
  overlayShowTimer = setTimeout(() => {
    document.getElementById('winnerOverlay').classList.add('active');
    launchConfetti();
  }, 200);

  overlayHideTimer = setTimeout(() => {
    document.getElementById('winnerOverlay').classList.remove('active');
  }, 5000);
}

// ─── CONFETTI ───────────────────────────────────────────
function launchConfetti() {
  if (confettiAnimFrame) { cancelAnimationFrame(confettiAnimFrame); confettiAnimFrame = null; }
  const c = document.getElementById('confetti');
  const ctx = c.getContext('2d');
  c.width = window.innerWidth;
  c.height = window.innerHeight;

  const neonColors = ['#00ffaa','#00d4ff','#a855f7','#22d3ee','#34d399','#60a5fa','#8b5cf6'];
  const pieces = [];
  for (let i = 0; i < 220; i++) {
    pieces.push({
      x: c.width / 2 + (Math.random() - 0.5) * 400,
      y: c.height * 0.4,
      w: 3 + Math.random() * 5,
      h: 8 + Math.random() * 12,
      color: neonColors[Math.floor(Math.random() * neonColors.length)],
      vx: (Math.random() - 0.5) * 16,
      vy: -12 - Math.random() * 14,
      rot: Math.random() * Math.PI * 2,
      rv: (Math.random() - 0.5) * 0.3,
      opacity: 1,
      glow: Math.random() > 0.4
    });
  }
  let frame = 0;
  function animate() {
    ctx.clearRect(0, 0, c.width, c.height);
    frame++;
    let alive = false;
    pieces.forEach(p => {
      p.vx *= 0.99;
      p.vy += 0.16;
      p.x += p.vx;
      p.y += p.vy;
      p.rot += p.rv;
      if (frame > 50) p.opacity -= 0.012;
      if (p.opacity <= 0) return;
      alive = true;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.globalAlpha = Math.max(0, p.opacity);
      if (p.glow) { ctx.shadowColor = p.color; ctx.shadowBlur = 10; }
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
      ctx.restore();
    });
    if (alive) confettiAnimFrame = requestAnimationFrame(animate);
    else { ctx.clearRect(0, 0, c.width, c.height); confettiAnimFrame = null; }
  }
  confettiAnimFrame = requestAnimationFrame(animate);
}

// ─── TEXTAREA SHUFFLE ───────────────────────────────────
const shuffleBtn = document.getElementById('shuffleBtn');
let shuffling = false;

function shuffleTextarea() {
  names = getNames();
  if (names.length < 2) return;
  if (shuffling || racing) return;
  shuffling = true;
  shuffleBtn.disabled = true;

  const finalNames = [...names];
  shuffle(finalNames);

  // Animate: rapidly scramble the textarea text, then settle
  let tick = 0;
  const totalTicks = 15;

  function scrambleTick() {
    if (tick >= totalTicks) {
      // Set final shuffled order
      namesEl.value = finalNames.join('\n');
      namesEl.dispatchEvent(new Event('input'));
      shuffling = false;
      shuffleBtn.disabled = false;
      return;
    }

    // Show a random permutation each tick
    const temp = [...names];
    shuffle(temp);
    namesEl.value = temp.join('\n');
    tick++;

    // Slow down toward the end
    const progress = tick / totalTicks;
    const delay = 30 + progress * 100;
    setTimeout(scrambleTick, delay);
  }

  scrambleTick();
}

</script>
</body>
</html>
